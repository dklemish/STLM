{
    "collab_server" : "",
    "contents" : "// Declare dependencies so Rcpp knows to link libraries\n// [[Rcpp::depends(RcppGSL)]]\n\n#include <R.h>\n#include <Rmath.h>\n#include <RcppGSL.h>\n#include <gsl/gsl_sf_expint.h>\n#include <gsl/gsl_sf_exp.h>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n\nusing namespace Rcpp;\n\n/** Global variables **/\ndouble shape, rate; // Gamma shape & rate parameters\ndouble epsilon;     // Epsilon Levy threshold\ndouble radius;      // Spatial radius\ndouble tau;\ndouble u;\nint type;         // type indicator for covariance shape\nint dimSpatial;   // number of dimensions needed for cov shape\nint nLoc;         // number of locations\nint dimX;         // number of columns of X\nint numMassPts;   // total number of mass points\nint numDraws;\nint totalDraws;\n\n/** Function headers **/\ndouble E1(double);\ndouble E1inv(double, double, bool);\nstd::vector<double> drawGamma(int, double, double, double);\n\nSEXP E1(SEXP);\nSEXP E1inv(SEXP, SEXP, SEXP);\nSEXP drawGamma(SEXP, SEXP, SEXP, SEXP);\n\n// Exponential integral functions\ndouble E1(double x){return(gsl_sf_expint_E1(x));}\ndouble E1inv(double y, double epsilon, bool Newton){\n  double x_old = R::qgamma(1.0e-9*y, 1e-9, 1.0, 0, 0);\n  if(Newton == FALSE){\n    return(x_old);\n  }else{\n    double x_new = 0;\n    double diff = 1.0e9;\n    \n    while(diff > epsilon){\n      x_new = x_old * (1 + gsl_sf_exp(x_old)*(gsl_sf_expint_E1(x_old) - y));\n      diff = std::abs(x_new - x_old);\n      x_old = x_new;\n    }\n    \n    return(x_new);\n  }\n}\n\n// [[Rcpp::export]]\nSEXP E1(SEXP x){\n  return(wrap(E1(as<double>(x))));\n}\n\n// [[Rcpp::export]]\nSEXP E1inv(SEXP y, SEXP epsilon, SEXP Newton){\n  return(wrap(E1inv(as<double>(y), as<double>(epsilon), as<bool>(Newton))));\n}\n\n// [[Rcpp::export]]\nSEXP drawGamma(SEXP init_elem, SEXP shape, SEXP rate, SEXP epsilon){\n  double shape_ = as<double>(shape);\n  double rate_ = as<double>(rate);\n  double epsilon_ = as<double>(epsilon);\n  \n  return(wrap(drawGamma(as<int>(init_elem), \n                        shape_, \n                        rate_,\n                        epsilon_)));\n}\n\nstd::vector<double> drawGamma(int init_elem, double shape, double rate, double epsilon){\n  // Draw Gamma random variable using the Inverse Levy Measure \n  // approach of Wolpert & Ickstadt\n  \n  // Returns a vector of mass values such that the sum of all mass values \n  // is a draw from a Gamma(shape, rate) distribution (up to an error of epsilon)\n  const double E1inv_epsilon = 1e-15;\n  \n  std::vector<double> result(init_elem);\n  \n  numDraws = 0;\n  tau = 0;\n  u = std::numeric_limits<double>::infinity();\n  \n  tau = R::rexp(1.0);\n  u = E1inv(tau/shape, E1inv_epsilon, FALSE)/rate;\n  result[numDraws++] = u;\n  \n  while(u > epsilon){\n    tau += R::rexp(1.0);\n    u = E1inv(tau/shape, E1inv_epsilon, FALSE)/rate;\n    result[numDraws++] = u;\n    \n    if(numDraws == init_elem){\n      init_elem = 2*init_elem;\n      result.resize(init_elem);\n    }\n  }\n  return(result);\n}\n\n// [[Rcpp::export]]\nSEXP drawGammaRF_1D(SEXP X_,\n                    SEXP shape_,\n                    SEXP rate_,\n                    SEXP epsilon_,\n                    SEXP radius_,\n                    SEXP type_,\n                    SEXP distMatrix_){\n  // Variable definitions\n  std::vector<double> levyDraws;\n  std::vector<std::vector<double> > massPts;\n  int i, j, k;\n  double tempLoc;\n  bool validLoc;\n  NumericVector Y;\n  \n  // Input data\n  // Convert SEXP objects to Rcpp objects\n  NumericMatrix X = as<NumericMatrix>(X_);\n  nLoc = X.nrow();\n  dimX = 1;\n  NumericMatrix distMatrix = as<NumericMatrix>(distMatrix_);\n  \n  shape   = as<double>(shape_);\n  rate    = as<double>(rate_);\n  epsilon = as<double>(epsilon_);\n  radius  = as<double>(radius_);\n  type    = as<int>(type_);\n  \n  numMassPts = nLoc*10; // initial # of mass points needed for all locations; grow as necessary\n  totalDraws = 0;\n  \n  Y = NumericVector(nLoc);\n  \n  dimSpatial = dimX + 2; // Number of spatial dimensions + 2 (for Levy mass value & \"height\")\n  \n  massPts = std::vector<std::vector<double> > (numMassPts, std::vector<double>(dimSpatial));\n  \n  GetRNGstate();\n  \n  levyDraws = drawGamma(20, shape, rate, epsilon); // Draw mass points for first location\n  \n  if(numDraws > numMassPts){\n    while(numDraws > numMassPts){\n      massPts.reserve(2*numMassPts);\n      numMassPts = 2*numMassPts;\n    }\n  }\n  \n  // Assign draws for first location to point in space\n  for(j = 0; j < numDraws; j++){\n    massPts.push_back(std::vector<double>(dimSpatial));\n    massPts[j][0] = levyDraws[j];\n    massPts[j][1] = X[0] + R::runif(-1*radius, radius);\n  }\n  totalDraws += numDraws;\n  \n  // Loop through remaining locations, drawing mass points and assigning \n  // them to points in space not yet accounted for by previous locations\n  for(i = 1; i < nLoc; i++){\n    levyDraws = drawGamma(20, shape, rate, epsilon);\n    \n    if((totalDraws + numDraws) > numMassPts){\n      while((totalDraws + numDraws) > numMassPts){\n        massPts.reserve(2*numMassPts);\n        numMassPts = 2*numMassPts;\n        Rcout << \"Resized!\" << std::endl;\n      }\n    }\n\n    // Assign mass point to location in space\n    for(j = 0; j < numDraws; j++){\n      tempLoc = X[i] + R::runif(-1*radius, radius);\n      validLoc = TRUE;\n      // Check previous locations; only need to check if current location is \n      // within 2*radius of previous location\n      for(k = 0; (k<i) & validLoc; k++){\n        if(distMatrix(i,k) < 2*radius){\n          validLoc = validLoc & (std::abs(X[k] - tempLoc) > radius); \n        }\n      }\n      // Current draw not in any previous location's \"shape\"\n      if(validLoc){\n        massPts.push_back(std::vector<double>(dimSpatial));\n        massPts[totalDraws][0] = levyDraws[j];\n        massPts[totalDraws++][1] = tempLoc;\n      }\n    }\n  }\n  \n  // Calculate value of random variable at each location\n  for(i = 0; i < nLoc; i++){\n    for(j = 0; j < totalDraws; j++){\n      if(std::abs(X[i] - massPts[j][1]) < radius){\n        Y(i) += massPts[j][0];\n      }\n    }    \n  }\n  \n  // Create NumericMatrix holding mass points\n  // NumericMatrix mp(totalDraws, 2);\n  // for(i = 0; i < totalDraws; i++){\n  //   mp(i,0) = massPts[i][0];\n  //   mp(i,1) = massPts[i][1];\n  // }    \n  \n  return(wrap(Y));\n  // return(List::create(Named(\"massPts\") = mp, \n  //                     Named(\"Y\") = Y));\n}\n\n// SEXP drawGammaRF_2D(SEXP X_,\n//                     SEXP shape_,\n//                     SEXP rate_,\n//                     SEXP epsilon_,\n//                     SEXP radius_,\n//                     SEXP type_,\n//                     SEXP distMatrix_){\n//   // Variable definitions\n//   std::vector<double> levyDraws;\n//   std::vector<std::vector<double> > massPts;\n//   \n//   // Input data\n//   // Convert SEXP objects to Rcpp objects\n//   NumericMatrix X = as<NumericMatrix>(X_);\n//   nLoc = X.nrow();\n//   dimX = 1;\n//   \n//   shape   = as<double>(shape_);\n//   rate    = as<double>(rate_);\n//   epsilon = as<double>(epsilon_);\n//   radius  = as<double>(radius_);\n//   type    = as<int>(type_);\n//   \n//   numMassPts = 1000; // initial # of mass points needed for all locations; grow as necessary\n//   \n//   dimSpatial = dimX + 1; // Number of spatial dimensions + 1 for Levy measure mass value\n//   \n//   massPts = std::vector<std::vector<double> > (numMassPts, std::vector<double>(dimSpatial));\n//   \n//   GetRNGstate();\n//   \n//   levyDraws = drawGamma(20, epsilon, shape, rate); // Draw mass points for first location\n//   numDraws = levyDraws.size();\n//   \n//   // Assign draws to a location\n//   \n//   \n//   // Store results\n//   NumericMatrix result(numMassPts, dimSpatial);\n//   for(int i = 0; i < numMassPts; i++){\n//     for(int j = 0; j < dimSpatial; j++){\n//       result(i,j) = massPts[i][j];  \n//     }\n//   }\n//   return(wrap(X));\n// }\n\n// \n// // [[Rcpp::export]]\n// SEXP drawRF_Gamma1D(SEXP X_, \n//                     SEXP shape_, \n//                     SEXP rate_, \n//                     SEXP epsilon_, \n//                     SEXP radius_)\n// {\n//   NumericVector X = as<NumericVector>(X_);\n//   NumericVector numMassPts = NumericVector(X.nrow());\n//   NumericVector levyDraws;\n//   IntegerVector locToStore;\n//   double shape    = as<double>(shape_);\n//   double rate     = as<double>(rate_);\n//   double epsilon  = as<double>(epsilon_);\n//   double radius   = as<double>(radius_);\n//   double nu_plus;\n//   NumericVector draw_radius;\n//   NumericVector draw_angle;\n//   int totalMassPts = 0;\n//   int num_draws;\n//   int i;\n//   \n//   nu_plus = shape*E1(rate*epsilon);\n//   \n//   NumericMatrix massPts = mat(10*round(nu_plus*X.nrow()), 2, fill::zeros);\n//   \n//   //Draw mass points for first location\n//   levyDraws = drawGamma(epsilon, shape, rate, nu_plus);\n//   \n//   num_draws = levyDraws.size();\n//   draw_radius = runif(num_draws, 0.0, radius);\n//   for(i = 0; i < num_draws; i++){\n//     draw_radius[i] = sqrt(draw_radius[i]);\n//   }\n//   draw_angle  = runif(num_draws, 0.0, 2*PI);\n// \n//   locToStore = seq(totalMassPts + 1, totalMassPts + num_draws);\n//   massPts[locToStore, 1] = levyDraws;\n//   massPts[locToStore, 2] = draw.radius*cos(draw.angle) + X[1];\n// \n//   numAdded[1] <- num.draws\n//   total.mass.pts <- total.mass.pts + num.draws\n//     \n//     for(i in 2:nrow(X)){\n// # Draw mass points for other locations, but discard points that fall \n// # in the regions of previous locations\n//       levy.draws <- drawGammaLM(1e-5, 10, 1, norm.constant)\n//       num.draws <- length(levy.draws)\n//       draw.radius <- sqrt(runif(num.draws, 0, R))\n//       draw.angle <- runif(num.draws, 0, 2*pi)\n//       \n//       x.loc <- X[i,1] + draw.radius*cos(draw.angle)\n//       y.loc <- X[i,2] + draw.radius*sin(draw.angle)\n//       \n//       valid.new.pt <- rep(TRUE, num.draws)\n//       \n//       for(j in 1:(i-1)){\n//         valid.new.pt <- valid.new.pt & !(((x.loc-X[j,1])^2 + (y.loc-X[j,2])^2) < R^2)\n//       }\n//       \n//       num.new <- sum(valid.new.pt)\n//         num.added[i] <- num.new\n//         \n//         if(num.new > 0){\n//           mass.pts[(total.mass.pts+1):(total.mass.pts+num.new), 1] <- levy.draws[valid.new.pt]\n//           mass.pts[(total.mass.pts+1):(total.mass.pts+num.new), 2] <- x.loc[valid.new.pt]\n//           mass.pts[(total.mass.pts+1):(total.mass.pts+num.new), 3] <- y.loc[valid.new.pt]\n//           total.mass.pts <- total.mass.pts + num.new\n//         }\n//     }\n//     Y <- rep(0, nrow(X))\n//       for(i in 1:nrow(X)){\n//         Y[i] <- sum(mass.pts[(mass.pts[,2]-X[i,1])^2 + (mass.pts[,3]-X[i,2])^2 < R^2,1])\n//       }\n//       \n//       return(cbind(X, Y, num.added))\n// }",
    "created" : 1522420070127.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1467092771",
    "id" : "E77086C5",
    "lastKnownWriteTime" : 1523293847,
    "last_content_update" : 1523293847498,
    "path" : "~/STLM/src/STLM.cpp",
    "project_path" : "src/STLM.cpp",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}